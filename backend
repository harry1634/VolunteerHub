from fastapi import FastAPI, APIRouter, HTTPException, Depends, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
from pathlib import Path
from pydantic import BaseModel, Field, ConfigDict, EmailStr
from typing import List, Optional
import uuid
from datetime import datetime, timezone, timedelta
import bcrypt
import jwt

ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# MongoDB connection
mongo_url = os.environ['MONGO_URL']
client = AsyncIOMotorClient(mongo_url)
db = client[os.environ['DB_NAME']]

# JWT Configuration
JWT_SECRET = os.environ.get('JWT_SECRET', 'your-secret-key-change-in-production')
JWT_ALGORITHM = 'HS256'
JWT_EXPIRATION_HOURS = 24

security = HTTPBearer()

app = FastAPI()
api_router = APIRouter(prefix="/api")

# ============ MODELS ============

class User(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    email: EmailStr
    full_name: str
    role: str  # 'volunteer' or 'organizer'
    skills: Optional[List[str]] = []
    interests: Optional[List[str]] = []
    availability: Optional[str] = ""
    organization_name: Optional[str] = ""  # For organizers
    phone: Optional[str] = ""
    total_hours: float = 0.0
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class UserRegister(BaseModel):
    email: EmailStr
    password: str
    full_name: str
    role: str
    skills: Optional[List[str]] = []
    interests: Optional[List[str]] = []
    availability: Optional[str] = ""
    organization_name: Optional[str] = ""
    phone: Optional[str] = ""

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserUpdate(BaseModel):
    full_name: Optional[str] = None
    skills: Optional[List[str]] = None
    interests: Optional[List[str]] = None
    availability: Optional[str] = None
    organization_name: Optional[str] = None
    phone: Optional[str] = None

class Event(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    title: str
    description: str
    location: str
    date: str
    time: str
    cause: str
    skills_required: List[str] = []
    total_spots: int
    available_spots: int
    organizer_id: str
    organizer_name: str
    organizer_email: str
    organizer_phone: str
    organizer_organization: str
    status: str = "open"  # open, closed, completed
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class EventCreate(BaseModel):
    title: str
    description: str
    location: str
    date: str
    time: str
    cause: str
    skills_required: List[str] = []
    total_spots: int

class EventUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    location: Optional[str] = None
    date: Optional[str] = None
    time: Optional[str] = None
    cause: Optional[str] = None
    skills_required: Optional[List[str]] = None
    total_spots: Optional[int] = None
    status: Optional[str] = None

class EventSignup(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    event_id: str
    volunteer_id: str
    volunteer_name: str
    volunteer_email: str
    status: str = "registered"  # registered, attended, cancelled
    hours_contributed: float = 0.0
    signed_up_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class SignupCreate(BaseModel):
    event_id: str

class AttendanceUpdate(BaseModel):
    signup_id: str
    status: str  # attended or cancelled
    hours_contributed: Optional[float] = 0.0

class Feedback(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    event_id: str
    volunteer_id: str
    volunteer_name: str
    rating: int
    comment: str
    organizer_response: Optional[str] = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class FeedbackCreate(BaseModel):
    event_id: str
    rating: int
    comment: str

class FeedbackResponse(BaseModel):
    feedback_id: str
    response: str

class Message(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    event_id: str
    user_id: str
    user_name: str
    user_role: str
    message: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class MessageCreate(BaseModel):
    event_id: str
    message: str

class AuthResponse(BaseModel):
    token: str
    user: User

# ============ AUTH HELPERS ============

def hash_password(password: str) -> str:
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

def verify_password(password: str, hashed: str) -> bool:
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

def create_token(user_id: str) -> str:
    expiration = datetime.now(timezone.utc) + timedelta(hours=JWT_EXPIRATION_HOURS)
    payload = {
        'user_id': user_id,
        'exp': expiration
    }
    return jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> dict:
    try:
        token = credentials.credentials
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        user_id = payload.get('user_id')
        
        user = await db.users.find_one({'id': user_id}, {'_id': 0, 'password': 0})
        if not user:
            raise HTTPException(status_code=401, detail="User not found")
        
        return user
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")

# ============ AUTH ROUTES ============

@api_router.post("/auth/register", response_model=AuthResponse)
async def register(user_data: UserRegister):
    # Check if user already exists
    existing = await db.users.find_one({'email': user_data.email})
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # Hash password
    hashed_pw = hash_password(user_data.password)
    
    # Create user
    user = User(
        email=user_data.email,
        full_name=user_data.full_name,
        role=user_data.role,
        skills=user_data.skills or [],
        interests=user_data.interests or [],
        availability=user_data.availability or "",
        organization_name=user_data.organization_name or "",
        phone=user_data.phone or ""
    )
    
    user_dict = user.model_dump()
    user_dict['password'] = hashed_pw
    user_dict['created_at'] = user_dict['created_at'].isoformat()
    
    await db.users.insert_one(user_dict)
    
    token = create_token(user.id)
    return AuthResponse(token=token, user=user)

@api_router.post("/auth/login", response_model=AuthResponse)
async def login(credentials: UserLogin):
    user = await db.users.find_one({'email': credentials.email}, {'_id': 0})
    if not user or not verify_password(credentials.password, user['password']):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    # Convert datetime string back to datetime object for response
    if isinstance(user['created_at'], str):
        user['created_at'] = datetime.fromisoformat(user['created_at'])
    
    # Remove password from response
    user.pop('password')
    token = create_token(user['id'])
    
    return AuthResponse(token=token, user=User(**user))

@api_router.get("/auth/me", response_model=User)
async def get_me(current_user: dict = Depends(get_current_user)):
    if isinstance(current_user['created_at'], str):
        current_user['created_at'] = datetime.fromisoformat(current_user['created_at'])
    return User(**current_user)

@api_router.put("/auth/profile", response_model=User)
async def update_profile(updates: UserUpdate, current_user: dict = Depends(get_current_user)):
    update_data = {k: v for k, v in updates.model_dump().items() if v is not None}
    
    if update_data:
        await db.users.update_one(
            {'id': current_user['id']},
            {'$set': update_data}
        )
    
    updated_user = await db.users.find_one({'id': current_user['id']}, {'_id': 0, 'password': 0})
    if isinstance(updated_user['created_at'], str):
        updated_user['created_at'] = datetime.fromisoformat(updated_user['created_at'])
    
    return User(**updated_user)

# ============ EVENT ROUTES ============

@api_router.post("/events", response_model=Event)
async def create_event(event_data: EventCreate, current_user: dict = Depends(get_current_user)):
    if current_user['role'] != 'organizer':
        raise HTTPException(status_code=403, detail="Only organizers can create events")
    
    event = Event(
        **event_data.model_dump(),
        available_spots=event_data.total_spots,
        organizer_id=current_user['id'],
        organizer_name=current_user['full_name'],
        organizer_email=current_user['email'],
        organizer_phone=current_user.get('phone', ''),
        organizer_organization=current_user.get('organization_name', '')
    )
    
    event_dict = event.model_dump()
    event_dict['created_at'] = event_dict['created_at'].isoformat()
    
    await db.events.insert_one(event_dict)
    return event

@api_router.get("/events", response_model=List[Event])
async def get_events(
    status: Optional[str] = None,
    cause: Optional[str] = None,
    search: Optional[str] = None
):
    query = {}
    if status:
        query['status'] = status
    if cause:
        query['cause'] = cause
    if search:
        query['$or'] = [
            {'title': {'$regex': search, '$options': 'i'}},
            {'description': {'$regex': search, '$options': 'i'}},
            {'location': {'$regex': search, '$options': 'i'}}
        ]
    
    events = await db.events.find(query, {'_id': 0}).to_list(1000)
    for event in events:
        if isinstance(event['created_at'], str):
            event['created_at'] = datetime.fromisoformat(event['created_at'])
    
    return events

@api_router.get("/events/{event_id}", response_model=Event)
async def get_event(event_id: str):
    event = await db.events.find_one({'id': event_id}, {'_id': 0})
    if not event:
        raise HTTPException(status_code=404, detail="Event not found")
    
    if isinstance(event['created_at'], str):
        event['created_at'] = datetime.fromisoformat(event['created_at'])
    
    return Event(**event)

@api_router.put("/events/{event_id}", response_model=Event)
async def update_event(
    event_id: str,
    updates: EventUpdate,
    current_user: dict = Depends(get_current_user)
):
    event = await db.events.find_one({'id': event_id})
    if not event:
        raise HTTPException(status_code=404, detail="Event not found")
    
    if event['organizer_id'] != current_user['id']:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    update_data = {k: v for k, v in updates.model_dump().items() if v is not None}
    
    # If total_spots is updated, adjust available_spots
    if 'total_spots' in update_data:
        current_signups = await db.signups.count_documents({
            'event_id': event_id,
            'status': 'registered'
        })
        new_available = update_data['total_spots'] - current_signups
        update_data['available_spots'] = max(0, new_available)
    
    if update_data:
        await db.events.update_one({'id': event_id}, {'$set': update_data})
    
    updated_event = await db.events.find_one({'id': event_id}, {'_id': 0})
    if isinstance(updated_event['created_at'], str):
        updated_event['created_at'] = datetime.fromisoformat(updated_event['created_at'])
    
    return Event(**updated_event)

@api_router.delete("/events/{event_id}")
async def delete_event(event_id: str, current_user: dict = Depends(get_current_user)):
    event = await db.events.find_one({'id': event_id})
    if not event:
        raise HTTPException(status_code=404, detail="Event not found")
    
    if event['organizer_id'] != current_user['id']:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    await db.events.delete_one({'id': event_id})
    return {"message": "Event deleted successfully"}

@api_router.get("/events/organizer/{organizer_id}", response_model=List[Event])
async def get_organizer_events(organizer_id: str):
    events = await db.events.find({'organizer_id': organizer_id}, {'_id': 0}).to_list(1000)
    for event in events:
        if isinstance(event['created_at'], str):
            event['created_at'] = datetime.fromisoformat(event['created_at'])
    
    return events

# ============ SIGNUP ROUTES ============

@api_router.post("/signups", response_model=EventSignup)
async def signup_for_event(signup_data: SignupCreate, current_user: dict = Depends(get_current_user)):
    if current_user['role'] != 'volunteer':
        raise HTTPException(status_code=403, detail="Only volunteers can sign up for events")
    
    event = await db.events.find_one({'id': signup_data.event_id})
    if not event:
        raise HTTPException(status_code=404, detail="Event not found")
    
    if event['available_spots'] <= 0:
        raise HTTPException(status_code=400, detail="No available spots")
    
    if event['status'] != 'open':
        raise HTTPException(status_code=400, detail="Event is not open for registration")
    
    # Check if already signed up
    existing = await db.signups.find_one({
        'event_id': signup_data.event_id,
        'volunteer_id': current_user['id'],
        'status': 'registered'
    })
    if existing:
        raise HTTPException(status_code=400, detail="Already signed up for this event")
    
    signup = EventSignup(
        event_id=signup_data.event_id,
        volunteer_id=current_user['id'],
        volunteer_name=current_user['full_name'],
        volunteer_email=current_user['email']
    )
    
    signup_dict = signup.model_dump()
    signup_dict['signed_up_at'] = signup_dict['signed_up_at'].isoformat()
    
    await db.signups.insert_one(signup_dict)
    
    # Update available spots
    await db.events.update_one(
        {'id': signup_data.event_id},
        {'$inc': {'available_spots': -1}}
    )
    
    return signup

@api_router.delete("/signups/{event_id}")
async def withdraw_from_event(event_id: str, current_user: dict = Depends(get_current_user)):
    signup = await db.signups.find_one({
        'event_id': event_id,
        'volunteer_id': current_user['id'],
        'status': 'registered'
    })
    
    if not signup:
        raise HTTPException(status_code=404, detail="Signup not found")
    
    await db.signups.update_one(
        {'id': signup['id']},
        {'$set': {'status': 'cancelled'}}
    )
    
    # Update available spots
    await db.events.update_one(
        {'id': event_id},
        {'$inc': {'available_spots': 1}}
    )
    
    return {"message": "Withdrawn successfully"}

@api_router.get("/signups/event/{event_id}", response_model=List[EventSignup])
async def get_event_signups(event_id: str, current_user: dict = Depends(get_current_user)):
    event = await db.events.find_one({'id': event_id})
    if not event:
        raise HTTPException(status_code=404, detail="Event not found")
    
    if event['organizer_id'] != current_user['id']:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    signups = await db.signups.find({'event_id': event_id}, {'_id': 0}).to_list(1000)
    for signup in signups:
        if isinstance(signup['signed_up_at'], str):
            signup['signed_up_at'] = datetime.fromisoformat(signup['signed_up_at'])
    
    return signups

@api_router.get("/signups/volunteer/me", response_model=List[EventSignup])
async def get_my_signups(current_user: dict = Depends(get_current_user)):
    signups = await db.signups.find(
        {'volunteer_id': current_user['id']},
        {'_id': 0}
    ).to_list(1000)
    
    for signup in signups:
        if isinstance(signup['signed_up_at'], str):
            signup['signed_up_at'] = datetime.fromisoformat(signup['signed_up_at'])
    
    return signups

@api_router.put("/signups/attendance")
async def update_attendance(attendance: AttendanceUpdate, current_user: dict = Depends(get_current_user)):
    signup = await db.signups.find_one({'id': attendance.signup_id})
    if not signup:
        raise HTTPException(status_code=404, detail="Signup not found")
    
    event = await db.events.find_one({'id': signup['event_id']})
    if event['organizer_id'] != current_user['id']:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    update_data = {'status': attendance.status}
    if attendance.status == 'attended' and attendance.hours_contributed:
        update_data['hours_contributed'] = attendance.hours_contributed
        
        # Update volunteer total hours
        await db.users.update_one(
            {'id': signup['volunteer_id']},
            {'$inc': {'total_hours': attendance.hours_contributed}}
        )
    
    await db.signups.update_one({'id': attendance.signup_id}, {'$set': update_data})
    
    return {"message": "Attendance updated successfully"}

# ============ FEEDBACK ROUTES ============

@api_router.post("/feedback", response_model=Feedback)
async def create_feedback(feedback_data: FeedbackCreate, current_user: dict = Depends(get_current_user)):
    if current_user['role'] != 'volunteer':
        raise HTTPException(status_code=403, detail="Only volunteers can submit feedback")
    
    # Check if volunteer attended the event
    signup = await db.signups.find_one({
        'event_id': feedback_data.event_id,
        'volunteer_id': current_user['id']
    })
    
    if not signup:
        raise HTTPException(status_code=400, detail="You must be registered for this event")
    
    feedback = Feedback(
        event_id=feedback_data.event_id,
        volunteer_id=current_user['id'],
        volunteer_name=current_user['full_name'],
        rating=feedback_data.rating,
        comment=feedback_data.comment
    )
    
    feedback_dict = feedback.model_dump()
    feedback_dict['created_at'] = feedback_dict['created_at'].isoformat()
    
    await db.feedback.insert_one(feedback_dict)
    return feedback

@api_router.get("/feedback/event/{event_id}", response_model=List[Feedback])
async def get_event_feedback(event_id: str):
    feedback = await db.feedback.find({'event_id': event_id}, {'_id': 0}).to_list(1000)
    for item in feedback:
        if isinstance(item['created_at'], str):
            item['created_at'] = datetime.fromisoformat(item['created_at'])
    
    return feedback

@api_router.put("/feedback/response")
async def respond_to_feedback(
    response_data: FeedbackResponse,
    current_user: dict = Depends(get_current_user)
):
    if current_user['role'] != 'organizer':
        raise HTTPException(status_code=403, detail="Only organizers can respond to feedback")
    
    feedback = await db.feedback.find_one({'id': response_data.feedback_id})
    if not feedback:
        raise HTTPException(status_code=404, detail="Feedback not found")
    
    event = await db.events.find_one({'id': feedback['event_id']})
    if event['organizer_id'] != current_user['id']:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    await db.feedback.update_one(
        {'id': response_data.feedback_id},
        {'$set': {'organizer_response': response_data.response}}
    )
    
    return {"message": "Response added successfully"}

# ============ MESSAGE ROUTES ============

@api_router.post("/messages", response_model=Message)
async def create_message(message_data: MessageCreate, current_user: dict = Depends(get_current_user)):
    message = Message(
        event_id=message_data.event_id,
        user_id=current_user['id'],
        user_name=current_user['full_name'],
        user_role=current_user['role'],
        message=message_data.message
    )
    
    message_dict = message.model_dump()
    message_dict['created_at'] = message_dict['created_at'].isoformat()
    
    await db.messages.insert_one(message_dict)
    return message

@api_router.get("/messages/event/{event_id}", response_model=List[Message])
async def get_event_messages(event_id: str):
    messages = await db.messages.find(
        {'event_id': event_id},
        {'_id': 0}
    ).sort('created_at', 1).to_list(1000)
    
    for msg in messages:
        if isinstance(msg['created_at'], str):
            msg['created_at'] = datetime.fromisoformat(msg['created_at'])
    
    return messages

# ============ REPORTS & STATS ============

@api_router.get("/volunteers")
async def get_volunteers(
    current_user: dict = Depends(get_current_user),
    skills: Optional[str] = None
):
    if current_user['role'] != 'organizer':
        raise HTTPException(status_code=403, detail="Only organizers can view volunteers")
    
    query = {'role': 'volunteer'}
    if skills:
        query['skills'] = {'$in': [skills]}
    
    volunteers = await db.users.find(
        query,
        {'_id': 0, 'password': 0}
    ).to_list(1000)
    
    for volunteer in volunteers:
        if isinstance(volunteer['created_at'], str):
            volunteer['created_at'] = datetime.fromisoformat(volunteer['created_at'])
    
    return volunteers

@api_router.get("/stats/volunteer")
async def get_volunteer_stats(current_user: dict = Depends(get_current_user)):
    if current_user['role'] != 'volunteer':
        raise HTTPException(status_code=403, detail="Only for volunteers")
    
    total_events = await db.signups.count_documents({
        'volunteer_id': current_user['id'],
        'status': 'attended'
    })
    
    return {
        'total_events_attended': total_events,
        'total_hours': current_user.get('total_hours', 0)
    }

@api_router.get("/stats/organizer")
async def get_organizer_stats(current_user: dict = Depends(get_current_user)):
    if current_user['role'] != 'organizer':
        raise HTTPException(status_code=403, detail="Only for organizers")
    
    total_events = await db.events.count_documents({'organizer_id': current_user['id']})
    
    total_volunteers = await db.signups.count_documents({
        'event_id': {'$in': [
            event['id'] for event in await db.events.find(
                {'organizer_id': current_user['id']},
                {'id': 1}
            ).to_list(1000)
        ]},
        'status': 'attended'
    })
    
    return {
        'total_events_created': total_events,
        'total_volunteers': total_volunteers
    }

# Include router
app.include_router(api_router)

app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),
    allow_methods=["*"],
    allow_headers=["*"],
)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()
